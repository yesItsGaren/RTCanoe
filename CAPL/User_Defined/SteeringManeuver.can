/*@!Encoding:65001*/
includes
{
  #include "testingSetSignals.CAN"
}

variables
{
  // Variables and constants
  const int sequenceRate = 100;
  const int sequenceRateFast = 10;
  const int preconditionsRate = 1000;
  const int SLEEP_VAL = 1;
  const int PARK_VAL = 2;
  const int AUTO_VAL = 3;
  const int VALID_STATE = 1;
  const int INVALID_STATE = 0;
  const int VALID_BRAKES = 1;
  const int DRIVE_GEAR = 1; // In SDS!!!!
  const int DISABLE_VCU_SIGNALS = 1; // 1 = On ; 0 = Off
  
  const float MAX_STEERING_ANGLE_PROFILE_0 = 507.0;
  const float MAX_STEERING_ANGLE_PROFILE_10 = 507.0;
  const float MAX_STEERING_ANGLE_PROFILE_20 = 297.0;
  const float MAX_STEERING_ANGLE_PROFILE_30 = 145.0;
  const float MAX_STEERING_ANGLE_PROFILE_40 = 87.5;
  const float MAX_STEERING_ANGLE_PROFILE_50 = 60.2;
  const float MAX_STEERING_ANGLE_PROFILE_60 = 45.6;
  
  const float TARGET_ACC_1 = 1.3;
  const float TARGET_ACC_2 = 2;
  const float TARGET_ACC_BRAKING = 2;
    
  float ACC_VAL = 1.3; // Acceleration Value, now dynamic
  
  const float TARGET_SPEED_PROFILE_0 = 0;
  const float TARGET_SPEED_PROFILE_10 = 10;
  const float TARGET_SPEED_PROFILE_20 = 20;
  const float TARGET_SPEED_PROFILE_30 = 30;
  const float TARGET_SPEED_PROFILE_40 = 40;
  const float TARGET_SPEED_PROFILE_50 = 50;
  const float TARGET_SPEED_PROFILE_60 = 60;
  const float TARGET_SPEED_PROFILE_ACC1 = 23.4;
  const float TARGET_SPEED_PROFILE_ACC2 = 36;
  const float TARGET_SPEED_PROFILE_BRAK_30 = 30;
  const float TARGET_SPEED_PROFILE_BRAK_50 = 50;
  
  
  const float TOLERANCE_ACC_PROFILE_0 = 0;
  const float TOLERANCE_ACC_PROFILE_10 = 2;
  const float TOLERANCE_ACC_PROFILE_20 = 2;
  const float TOLERANCE_ACC_PROFILE_30 = 2;
  const float TOLERANCE_ACC_PROFILE_40 = 2;
  const float TOLERANCE_ACC_PROFILE_50 = 2;
  const float TOLERANCE_ACC_PROFILE_60 = 2;
  const float TOLERANCE_ACC_PROFILE_ACC1 = 2;
  const float TOLERANCE_ACC_PROFILE_ACC2 = 2;
  
  const float STEERING_RATE_PROFILE_0 = 18.2;
  const float STEERING_RATE_PROFILE_0_SMOOTH = 1.82;
  const float STEERING_RATE_PROFILE_10 = 18.2;
  const float STEERING_RATE_PROFILE_20 = 8.8;
  const float STEERING_RATE_PROFILE_30 = 6.0;
  const float STEERING_RATE_PROFILE_40 = 4.3;
  const float STEERING_RATE_PROFILE_50 = 3.6;
  const float STEERING_RATE_PROFILE_60 = 3.2;
  
  
  enum ACC_PROFILE 
  {
    TG_003_Steering_0,
    TG_003_Steering_0_Smooth,
    TG_003_Steering_10,
    TG_003_Steering_20,
    TG_003_Steering_30,
    TG_003_Steering_40,
    TG_003_Steering_50,
    TG_003_Steering_60,
    TG_001_Acceleration_2_D1,
    TG_001_Acceleration_2_D2,
    TG_001_Acceleration_2_D1R,
    TG_001_Acceleration_2_D2R,
    TG_002_BRAKING_30_3_5,
    TG_002_BRAKING_30_5,
    TG_002_BRAKING_50_3_5,
    TG_002_BRAKING_50_5,
    TG_004_Steering_Braking_60,
    TG_003_Steering_50_limiter
  };
  
  int EXECUTED_MANEUVER;

  enum SDS_State
{
    PARK_STATE = 0,        // Park Mode
    AUTO_STATE = 1,        // Autonomous Mode
    MANEUVER_STATE = 2     // Maneuver Mode
};
  
enum ACC_IO
{
  STOP_ACC = 0,
  START_ACC = 1
};
  
  float calculatedSteeringValue = 0;
  float currentSpeed = 0;
  float NMinusOneSteeringVal = 0;
  float NMinusTwoSteeringVal = 0;
  float maxSteeringAngle;
  
  int preconditionsStep = 0;
  int steeringManeuverCount = 0;
  int SteeringCounter = 0;
  int accCount = 0;
  int intervalPointsArray[11];
  
  // Input Messages (Simulation)
  message CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim primSteeringMsg2; // Primary Steering Control Chassis 2 (0x14B)
  message CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec secSteeringMsg1;  // Secondary Steering Control Chassis 1 (0x14D)
  
  message CHASSIS1CAN::VCU_VSMInfo vsmInfoMsg1;  // VSM Status Chassis 1 (0x11A)
  message CHASSIS2CAN::VCU_VSMInfo vsmINfoMsg2;  // VSM Status Chassis 2 (0x11A)
  
  message CHASSIS1CAN::MKC1_VehMvmntInfo MK100_1; // Breaks Chassis 1 MK100 (0x16A)
  message CHASSIS2CAN::MKC1_VehMvmntInfo MKC1_2; // Breaks Chassis 2 MKC1 (0x16A)

  message PWT1CAN::CDM_Crash_Info PWT1CDMCrashInfo; // 50ms
  message PWT1CAN::DCS_Door_status PWT1DoorStat; // 50ms
  message PWT1CAN::RCS_Ramp_status PWT1RCSRampStatus; // 50ms
  message PWT1CAN::TCU_Erro_Info PWT1TCUErrorInfo; // 100ms
  message PWT1CAN::TCU_FuncReq2 PWT1TCUFuncReq; // 100ms
  message PWT1CAN::BCM_Error_Info PWT1BCMErrInf; // 100ms
  message PWT1CAN::ASS_Info PWT1AssInf; // 100ms
  message PWT1CAN::ASS_Error_Info PWT1AssErr; //100ms
  message PWT1CAN::VCU::VCU_FaultInfo PWT1VcuFaultInf; //100ms
  message PWT1CAN::VCU_HVInfo PWT1VcuHvInf; //100ms
  message PWT1CAN::VCU_Info PWT1VcuInf; //100ms
  message PWT1CAN::IPC_Stat PWT1IpcStat; //100ms
  message PWT1CAN::VCU_VSMInfo PWT1VcuVsmInf;  //100ms
  message PWT1CAN::MK100_SecBrkInfo PWT1MK100SecBrkInf;
  
  message CHASSIS2CAN::CGW::SDS_Stability_Info_Sec Chass2SDSStabInfSec;

  // Timers
  msTimer sequenceTimer;  // Timer for sequential execution
  msTimer sequenceTimerLimiter;
  msTimer preconditionsTimer;
  msTimer PWT100Timer;
  msTimer PWT50Timer;
  msTimer sequenceTimerSmooth;
  const int PWT50TimerVal = 50;
  const int PWT100TimerVal = 100;

  
  int maneuverInProgress = 0;

  //Test variables

  int k;
  float receivedPinionAngle;
  float receivedPinionAngle2;
  
  const float TOLERANCE = 2.5; // Acceptable tolerance range (±0.5 degrees)
  int nbOfTries = 0;
  int retVal = 0;
  int retryCount =0;
  const int MAX_RETRY_CNT = 9;
  int angle1Result;
  int angle2Result;
  
  
  // Test return values macros
  const int PASS = 1;
  const int FAIL = 0;
  
  // Manual intervention Detection variables
  int steeringState;
  const int MIN_STEERING_RATE = 10;
  const int MANUAL_STEERING_ACTIVE = 1;
  const int DELAY_1000_MS = 1000;
  int TIMEOUT_TURN_WHEEL = 10000;
  const int ENABLED = 1;
  const int DISABLED = 0;
  
  // ISCS test variables
  const int MAX_STEERING_TEST_BUFFER_SIZE = 300;
  const float ISCS_TEST_PINION_ANGLE_TOLERANCE = 2.5;
  float iscsPinionAngle1Buffer[MAX_STEERING_TEST_BUFFER_SIZE];
  float iscsPinionAngle2Buffer[MAX_STEERING_TEST_BUFFER_SIZE];
  float calculatedPinionAngleBuffer[MAX_STEERING_TEST_BUFFER_SIZE];
  int bufferIndex = 0;
  int validationTimer = 0;


  const int MAX_STEERING_TEST_BUFFER_SIZE0S = 3000;
  const float ISCS_TEST_PINION_ANGLE_TOLERANCE0S = 2.5;
  float iscsPinionAngle1Buffer0S[MAX_STEERING_TEST_BUFFER_SIZE0S];
  float iscsPinionAngle2Buffer0S[MAX_STEERING_TEST_BUFFER_SIZE0S];
  float calculatedPinionAngleBuffer0S[MAX_STEERING_TEST_BUFFER_SIZE0S];
}

// Function to start the sequence
void StartPreconditionSequence()
{
  // Start the sequence
  preconditionsStep = 0;
  PowerTrainPreconditions();
  setTimer(preconditionsTimer, preconditionsRate); 
}

void executeManeuver()
{
  
  int currentVCUState;
  //currentVCUState = getSignal(CHASSIS2CAN::VCU_VSMInfo::VSMStatus);
  currentVCUState = AUTO_VAL;
  
  if(currentVCUState == AUTO_VAL) // Check if we are in Autonomous mode and if a maneuver is not taking place
  {
    SteeringCounter = 0;
    PowerTrainPreconditions();
    teststep("Validate AUTO Mode","Starting Sequence with 100ms rate");
    setTimer(sequenceTimer,sequenceRate);
  }
  else
  {
    teststep("Validate AUTO Mode","Oops! Seems like you are not in Autonomous state or a maneuver is taking place. That's sad :(");
    TestStepFail("FAIL: Vehicle not in AUTO mode.");
  }
}


void executeManeuverLimiter()
{
  
  int currentVCUState;
  //currentVCUState = getSignal(CHASSIS2CAN::VCU_VSMInfo::VSMStatus);
  currentVCUState = AUTO_VAL;
  
  if(currentVCUState == AUTO_VAL) // Check if we are in Autonomous mode and if a maneuver is not taking place
  {
    SteeringCounter = 0;
    PowerTrainPreconditions();
    teststep("Validate AUTO Mode","Starting Sequence with 100ms rate");
    setTimer(sequenceTimerLimiter,sequenceRate);
  }
  else
  {
    teststep("Validate AUTO Mode","Oops! Seems like you are not in Autonomous state or a maneuver is taking place. That's sad :(");
    TestStepFail("FAIL: Vehicle not in AUTO mode.");
  }
}



void executeManeuverSmooth()
{
  
  int currentVCUState;
  currentVCUState = AUTO_VAL;
  
  if(currentVCUState == AUTO_VAL) // Check if we are in Autonomous mode and if a maneuver is not taking place
  {
    SteeringCounter = 0;
    PowerTrainPreconditions();
    teststep("Validate AUTO Mode","Starting Sequence with 100ms rate");
    setTimer(sequenceTimerSmooth,sequenceRateFast);
  }
  else
  {
    teststep("Validate AUTO Mode","Oops! Seems like you are not in Autonomous state or a maneuver is taking place. That's sad :(");
    TestStepFail("FAIL: Vehicle not in AUTO mode.");
  }
}


on timer PWT100Timer
{
  output(PWT1TCUErrorInfo);
  output(PWT1TCUFuncReq);
  output(Chass2SDSStabInfSec);
  setTimer(PWT100Timer,PWT100TimerVal);
}

on timer PWT50Timer
{
  output(PWT1CDMCrashInfo);
  output(PWT1DoorStat);
  output(PWT1RCSRampStatus);
  setTimer(PWT50Timer,PWT50TimerVal);
}

// Timer event for sequential execution
on timer preconditionsTimer
{
  switch (preconditionsStep)
  {
    case 0:
      // 0 - Set Sleep
      teststep(" ","Step 0: Set Sleep");
      if(DISABLE_VCU_SIGNALS == 0)
      {
        $CHASSIS1CAN::VCU_VSMInfo::VSMStatus = SLEEP_VAL;
        $CHASSIS2CAN::VCU_VSMInfo::VSMStatus = SLEEP_VAL;
      }
      preconditionsStep++;
      setTimer(preconditionsTimer, preconditionsRate); // 100ms delay before next step
      break;

    case 1:
      // 2 - Set SDS Steering validity to Valid
      teststep(" ","Step 1: Set SDS Steering validity to Valid");
      setSteeringValidity(VALID_STATE);
      preconditionsStep++;
      setTimer(preconditionsTimer, preconditionsRate); // 100ms delay before next step
      break;

    case 2:
      // 2 - Set Brake Validity to Valid
      teststep(" ","Step 2: Set Brake Validity to Valid");
      if(DISABLE_VCU_SIGNALS == 0)
      {
        //$CHASSIS1CAN::MKC1_VehMvmntInfo::VehSpeedValidStat = VALID_BRAKES;
        //$CHASSIS2CAN::MKC1_VehMvmntInfo::VehSpeedValidStat = VALID_BRAKES;
      }
      preconditionsStep++;
      setTimer(preconditionsTimer, preconditionsRate); // 100ms delay before next step
      break;

    case 3:
      // 3 - Set Park
      if(DISABLE_VCU_SIGNALS == 0)
      {
        //$CHASSIS1CAN::VCU_VSMInfo::VSMStatus = PARK_VAL;
        //$CHASSIS2CAN::VCU_VSMInfo::VSMStatus = PARK_VAL;
      }
      teststep(" ","Step 3: Set Park");
      preconditionsStep++;
      setTimer(preconditionsTimer, preconditionsRate); // 100ms delay before next step
      break;

    case 4:
      // 4 - Set Initial values
      teststep(" ","Step 4: Set initial Values");
      
      setSDSSimParams(PARK_STATE);
      
      preconditionsStep++;
      setTimer(preconditionsTimer, preconditionsRate); // 100ms delay before next step
      break;
      
    default:
      // End of sequence
      teststep(" ","Sequence Completed", "All steps executed successfully.");
      cancelTimer(preconditionsTimer);
      break;
  }
}

void setSDSSimParams(int State)
{
  switch(State)
  {
    case PARK_STATE:  
      $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::Valid_CtrlSteeringPinionAng_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = 0; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPriValidStat = 1; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = 2; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqPri = 0; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqValidityPri = 1; 
      
      $CHASSIS2CAN::SDS_Primary::SDS_SelfCheckInfo_Prim::SDSSlfCheckStatus_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::CurrentSDSModeStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::DestReachedStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::LaneChangeStat_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 3;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MRMStatPri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::SDSRequest_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::TeleOpReqStat_Pri = 2;
      
      
      
      $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::Valid_CtrlSteeringPinionAng_Sec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSecValidStat = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::GearchangeReq_Sec = 2;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqValiditySec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::CurrentSDSModeStat_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::DestReachedStat_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::LaneChangeStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MissionProgressStat_Sec = 3;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MRMStatSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::ParkingProcessStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::TeleOpReqStat_Sec = 2;
      
      Chass2SDSStabInfSec.AccelDecelReqSec = 0;
      Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
      Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
      Chass2SDSStabInfSec.VehStandStillReqSec = 0;
      Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
      setTimer(PWT100Timer,PWT100TimerVal);
      
      break;
    case AUTO_STATE:
      PowerTrainPreconditions();
      $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::Valid_CtrlSteeringPinionAng_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = 0; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPriValidStat = 1; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = 1; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqPri = 0; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqValidityPri = 1; 
      
      $CHASSIS2CAN::SDS_Primary::SDS_SelfCheckInfo_Prim::SDSSlfCheckStatus_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::CurrentSDSModeStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::DestReachedStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::LaneChangeStat_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 3;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MRMStatPri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::SDSRequest_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::TeleOpReqStat_Pri = 2;
      
      
      
      $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::Valid_CtrlSteeringPinionAng_Sec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSecValidStat = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::GearchangeReq_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqValiditySec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::CurrentSDSModeStat_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::DestReachedStat_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::LaneChangeStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MissionProgressStat_Sec = 3;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MRMStatSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::ParkingProcessStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::TeleOpReqStat_Sec = 2;
      
      Chass2SDSStabInfSec.AccelDecelReqSec = 0;
      Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
      Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
      Chass2SDSStabInfSec.VehStandStillReqSec = 0;
      Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
      setTimer(PWT100Timer,PWT100TimerVal);
      break;
    case MANEUVER_STATE:
      PowerTrainPreconditions();
      $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::Valid_CtrlSteeringPinionAng_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPriValidStat = 1; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = 1; 
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqPri = 2; // 2 seconds?
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqValidityPri = 1; 
      
      $CHASSIS2CAN::SDS_Primary::SDS_SelfCheckInfo_Prim::SDSSlfCheckStatus_Pri = 1;
      
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::CurrentSDSModeStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::DestReachedStat_Pri = 1;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::LaneChangeStat_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 5;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MRMStatPri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::SDSRequest_Pri = 0;
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::TeleOpReqStat_Pri = 2;
      
      
      
      $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::Valid_CtrlSteeringPinionAng_Sec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSecValidStat = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::GearchangeReq_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqSec = 2;
      $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::VehStandStillReqValiditySec = 1;
      
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::CurrentSDSModeStat_Sec = 4;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::DestReachedStat_Sec = 1;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::LaneChangeStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MissionProgressStat_Sec = 5;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::MRMStatSec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::ParkingProcessStat_Sec = 0;
      $CHASSIS1CAN::SDS_Secondary::SDS_Status_Sec::TeleOpReqStat_Sec = 2;
      
      
      
      break;
    default:
      break;
  }      
}


void PowerTrainPreconditions()
{
  PWT1RCSRampStatus.RampStatus = 0; //Retracted  NA in IG
  PWT1TCUFuncReq.CloudStartStopChargingRequest = 0; //No Charging Req
  PWT1TCUFuncReq.ControlCenterStartupRequest = 0; // vehicle Off
  PWT1TCUFuncReq.RequestRemoteDiagnosticMode = 0; // Inactive
  PWT1TCUFuncReq.StatusProviderGo = 1; // go Ahead with Mission
  PWT1TCUFuncReq.StatusCloudDataOpertn = 0; //DataTransfer_NotInprogress
  PWT1TCUFuncReq.RemoteChargingRequest = 0; // No Charging Req
  PWT1TCUFuncReq.StatusTelematicsConnectivity = 0; // Default
  PWT1TCUFuncReq.WakeUpIformation = 1; //wakeUp SMS Received
  PWT1TCUFuncReq.RemoteStartUpShutdownReq = 0; // Default
  PWT1TCUFuncReq.TCUSignalStrength = 4; // Good NA works
  PWT1DoorStat.DoorStatus = 0; // Closed NA in IG
  PWT1DoorStat.DoorEmgReleaseStatus = 0; //No emergenecy release. in IG
  PWT1CDMCrashInfo.CrashDetectionSysErrLvl = 0; // No Fault NA in IG
  PWT1CDMCrashInfo.CrashDetectedStat = 0; // No Fault NA in IG
  PWT1TCUErrorInfo.StatusTelematicsErrLvl = 0; // No Fault NA in IG
  
  setTimer(PWT100Timer,PWT100TimerVal);
  setTimer(PWT50Timer,PWT50TimerVal);
}

void setIntervals()
{
  int i=0;
  // Reset array values to 0 (optional, in case you want to clear it)
    for (i = 0; i < 10; i++) 
    {
        intervalPointsArray[i] = 0;
    }
    teststep(" ","Setting Interval points and Maximum steering angle");
   switch(EXECUTED_MANEUVER)
    {
      case TG_003_Steering_0:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_0;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 37;
            intervalPointsArray[4] = 38;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 211;
            intervalPointsArray[8] = 212;
            intervalPointsArray[9] = 300;  
        break;
      case TG_003_Steering_0_Smooth:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_0;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 99;
            intervalPointsArray[2] = 100;
            intervalPointsArray[3] = 377;
            intervalPointsArray[4] = 380;
            intervalPointsArray[5] = 1000;
            intervalPointsArray[6] = 1010;
            intervalPointsArray[7] = 1557;
            intervalPointsArray[8] = 2999;
            intervalPointsArray[9] = 3000;  
        break;
      case TG_003_Steering_10:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_10;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 37;
            intervalPointsArray[4] = 38;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 211;
            intervalPointsArray[8] = 212;
            intervalPointsArray[9] = 300;
        break;
        
      case TG_003_Steering_20:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_20;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 43;
            intervalPointsArray[4] = 44;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 234;
            intervalPointsArray[8] = 235;
            intervalPointsArray[9] = 300;
        break;
        
      case TG_003_Steering_30:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_30;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 34;
            intervalPointsArray[4] = 35;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 196;
            intervalPointsArray[8] = 197;
            intervalPointsArray[9] = 300;
        break;
        
      case TG_003_Steering_40:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_40;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 30;
            intervalPointsArray[4] = 31;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 180;
            intervalPointsArray[8] = 181;
            intervalPointsArray[9] = 300;
        break;
        
      case TG_003_Steering_50:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_50;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 26;
            intervalPointsArray[4] = 27;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 166;
            intervalPointsArray[8] = 167;
            intervalPointsArray[9] = 300;
        break;
        
      case TG_003_Steering_60:
      case TG_004_Steering_Braking_60:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_60;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 24;
            intervalPointsArray[4] = 25;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 156;
            intervalPointsArray[8] = 157;
            intervalPointsArray[9] = 300;
        break;
      default:
            maxSteeringAngle = MAX_STEERING_ANGLE_PROFILE_60;
            intervalPointsArray[0] = 0;
            intervalPointsArray[1] = 9;
            intervalPointsArray[2] = 10;
            intervalPointsArray[3] = 24;
            intervalPointsArray[4] = 25;
            intervalPointsArray[5] = 100;
            intervalPointsArray[6] = 101;
            intervalPointsArray[7] = 156;
            intervalPointsArray[8] = 157;
            intervalPointsArray[9] = 300;
        break;
    }
}

// Timer event for sequential execution
on timer sequenceTimer
{
  
  switch (SteeringCounter)
  {
    case 0: //0 - Set maneuver state and reset acc counter 
      maneuverInProgress = 1;
      teststep("Steering Test","Step 0: Set mission and reset acc counter");
      setSDSSimParams(MANEUVER_STATE);
      SteeringCounter++;
      setTimer(sequenceTimer, sequenceRate); // 100ms delay before next step
      break;

    case 1: // 1- Set Drive/Auto
      testStep("Steering Test","Step 1: Set Drive/Auto");
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = DRIVE_GEAR;
      TC001_testGearchangeReqPrimary(DRIVE_GEAR);
      if(DISABLE_VCU_SIGNALS == 0)
      {
        $CHASSIS1CAN::VCU_VSMInfo::VSMStatus = AUTO_VAL;
        $CHASSIS2CAN::VCU_VSMInfo::VSMStatus = AUTO_VAL;
      }
      
      /*---------------------------------------RUN TESTCASES: START--------------------------------------------*/
      TC002_verifySDSPrimarySignals();
      TC003_verifySDSSecondarySignals();
      TC004_verifyPWT1Signals();
      TC005_testVSMStatus(AUTO_VAL);
      /*---------------------------------------RUN TESTCASES: END----------------------------------------------*/
      
      SteeringCounter++;
      setTimer(sequenceTimer, sequenceRate); // 100ms delay before next step
      break;

    case 2:
      if(accCount == 0)
      {
        testStep("Steering Test","Step 2: Accelerate to target Speed");
      }
      
      // 2- Accelerate to targetSpeed
      accCount++;
      if(accCount == 22) // after 2 seconds since maneuver is executed reset to 0
      {
        $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqPri = 0;
        TC006_testVehStandStillReqPrimary(2);
      }
      accelerateToSpeed(START_ACC);
      
      if(accCount == 140) // Accelerate for 7 seconds max
      {
        SteeringCounter++;
        steeringManeuverCount = 0; // Reset counter
        accCount = 0; // Reset counter
        accelerateToSpeed(STOP_ACC); 
        setIntervals();
      }
      PowerTrainPreconditions();
      setTimer(sequenceTimer, sequenceRate); // 100ms delay before next step
      
      break;
      
    case 3:
      // 3 - Steer per test values (300 values in total) evrey 100ms
      //$CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::SteerRateReq_Pri =  50;
      
      if(steeringManeuverCount == 0)
      {
        testStep("Steering Test","Step 3: Steer per test values (300 values in total) evrey 100ms");
      }
      if(steeringManeuverCount <= intervalPointsArray[9])
      {
        bufferIndex++;
        accelerateToSpeed(START_ACC);
        if(bufferIndex < MAX_STEERING_TEST_BUFFER_SIZE)
        {
          calculatedPinionAngleBuffer[bufferIndex] = calculatedSteeringValue;
          write("calculatedSteeringValue recorded %d = %f",bufferIndex,calculatedSteeringValue);
          iscsPinionAngle1Buffer[bufferIndex] = degreesToRadians(getSignal(CHASSIS2CAN::ECU1_ISCS::ISCS_CurrPinionStat::CurrentSteeringPinionAngle));
          iscsPinionAngle2Buffer[bufferIndex] = degreesToRadians(getSignal(CHASSIS1CAN::ECU2_ISCS::ISCS_CurrPinionStat_2::CurrentSteeringPinionAngle_2));
        }
        
        steeringManeuverCount++;
        if((steeringManeuverCount <= intervalPointsArray[1]) && (steeringManeuverCount >= intervalPointsArray[0]))
        {
          if(steeringManeuverCount == intervalPointsArray[0])
          {
            calculatedSteeringValue = 0;
            NMinusOneSteeringVal = 0;
          }
          
          
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
          write("Step 3:Hold on zero %d to %d Val = %f",intervalPointsArray[0],intervalPointsArray[1],0);
        }
        else if((steeringManeuverCount < intervalPointsArray[3]) && (steeringManeuverCount >= intervalPointsArray[2]))
        {
          executePosSteering();
          if(EXECUTED_MANEUVER == TG_004_Steering_Braking_60)
          {
            // Brake maneuver if TG_004_Steering_Braking_60 is selected
            $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = -3.5;
            $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = -3.5;
            Chass2SDSStabInfSec.AccelDecelReqSec = -3.5;
            Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
            Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
            Chass2SDSStabInfSec.VehStandStillReqSec = 0;
            Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
            setTimer(PWT100Timer,PWT100TimerVal);
          }
        }
        else if((steeringManeuverCount <= intervalPointsArray[5]) && (steeringManeuverCount >= (intervalPointsArray[4] -1)))
        {

          if(steeringManeuverCount == intervalPointsArray[4])
          {
            calculatedSteeringValue = maxSteeringAngle;
            NMinusTwoSteeringVal = maxSteeringAngle;
          }
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(maxSteeringAngle);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(maxSteeringAngle);
          write("Step 3: hold on + max %d to %d Val = + %f",intervalPointsArray[4],intervalPointsArray[5],maxSteeringAngle);
        }
        else if((steeringManeuverCount <= intervalPointsArray[7]) && (steeringManeuverCount >= intervalPointsArray[6]))
        {
          executeNegSteering();
        }
        else if((steeringManeuverCount <= intervalPointsArray[9]) && (steeringManeuverCount >= intervalPointsArray[8]))
        {
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(-maxSteeringAngle);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec =  degreesToRadians(-maxSteeringAngle);
          write("Step 3: Hold on - max %d to %d Val = - %f",intervalPointsArray[8],intervalPointsArray[9],maxSteeringAngle);
        }
        else if(steeringManeuverCount >= intervalPointsArray[9])
        {
          // 4- Set mission to executed
          $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 7; // Mission arrived
          //accelerateToSpeed(0);
        }
      }
      else if(steeringManeuverCount >= (intervalPointsArray[9] + 1))
      {
        SteeringCounter++;
      }
      
      setTimer(sequenceTimer, sequenceRate); // 100ms delay before next step
      break;
    case 4:
      teststep("Steering Test","Step 4: Reset Mission and Steering Request angle.");
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 7; // Mission arrived
      $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
      $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
      accelerateToSpeed(STOP_ACC);
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 3; // Mission accepted
      validationTimer++;
      if(validationTimer > 50)
      {
        SteeringCounter++;
        validationTimer = 0;
      }
      TC007_validateISCS1SteeringResults();
      TC008_validateISCS2SteeringResults();
      testWaitForTimeout(TEST_STEERING_TIMOUT);
      
      setTimer(sequenceTimer, sequenceRate); // 100ms delay before next step
    default:
      // End of sequence
      calculatedSteeringValue = 0;
      NMinusTwoSteeringVal = 0;
      NMinusOneSteeringVal = 0;
      steeringManeuverCount = 0;
      cancelTimer(sequenceTimer);
      teststep("Steering Test","Sequence Completed", "All steps executed successfully.");
      maneuverInProgress = 0;
      break;
  }
}


on timer sequenceTimerSmooth
{
  
  switch (SteeringCounter)
  {
    case 0: //0 - Set maneuver state and reset acc counter 
      maneuverInProgress = 1;
      TC005_testVSMStatus(AUTO_VAL);
      teststep("Steering Test Smooth","Step 0: Set mission and reset acc counter");
      setSDSSimParams(MANEUVER_STATE);
      SteeringCounter++;
      setTimer(sequenceTimerSmooth, sequenceRateFast); // 100ms delay before next step
      break;

    case 1: // 1- Set Drive/Auto
      testStep("Steering Test","Step 1: Set Drive/Auto");
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = DRIVE_GEAR;
      TC001_testGearchangeReqPrimary(DRIVE_GEAR);

      /*---------------------------------------RUN TESTCASES: START--------------------------------------------*/
      TC002_verifySDSPrimarySignals();
      TC003_verifySDSSecondarySignals();
      TC004_verifyPWT1Signals();
      
      /*---------------------------------------RUN TESTCASES: END----------------------------------------------*/
      
      SteeringCounter++;
      setTimer(sequenceTimerSmooth, sequenceRateFast); // 100ms delay before next step
      break;

    case 2:
      if(accCount == 0)
      {
        testStep("Steering Test","Step 2: Accelerate to target Speed");
      }
      SteeringCounter++;
      steeringManeuverCount = 0; // Reset counter
      accCount = 0; // Reset counter
      accelerateToSpeed(STOP_ACC); 
      setIntervals();
      PowerTrainPreconditions();
      setTimer(sequenceTimerSmooth, sequenceRateFast); // 100ms delay before next step
      
      break;
      
    case 3:
      // 3 - Steer per test values (300 values in total) evrey 100ms
         
      if(steeringManeuverCount == 0)
      {
        testStep("Steering Test","Step 3: Steer per test values (300 values in total) evrey 100ms");
      }
      if(steeringManeuverCount <= intervalPointsArray[9])
      {
        bufferIndex++;
        if(bufferIndex < MAX_STEERING_TEST_BUFFER_SIZE0S)
        {
          calculatedPinionAngleBuffer0S[bufferIndex] = calculatedSteeringValue;
          write("calculatedSteeringValue recorded %d = %f",bufferIndex,calculatedSteeringValue);
          iscsPinionAngle1Buffer0S[bufferIndex] = degreesToRadians(getSignal(CHASSIS2CAN::ECU1_ISCS::ISCS_CurrPinionStat::CurrentSteeringPinionAngle));
          iscsPinionAngle2Buffer0S[bufferIndex] = degreesToRadians(getSignal(CHASSIS1CAN::ECU2_ISCS::ISCS_CurrPinionStat_2::CurrentSteeringPinionAngle_2));
        }
        
        steeringManeuverCount++;
        if((steeringManeuverCount <= intervalPointsArray[1]) && (steeringManeuverCount >= intervalPointsArray[0]))
        {
          if(steeringManeuverCount == intervalPointsArray[0])
          {
            calculatedSteeringValue = 0;
            NMinusOneSteeringVal = 0;
          }
          
          
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
          write("Step 3:Hold on zero %d to %d Val = %f",intervalPointsArray[0],intervalPointsArray[1],0);
        }
        else if((steeringManeuverCount < intervalPointsArray[3]) && (steeringManeuverCount >= intervalPointsArray[2]))
        {
          executePosSteering();
        }
        else if((steeringManeuverCount <= intervalPointsArray[5]) && (steeringManeuverCount >= (intervalPointsArray[4] -1)))
        {
          if(steeringManeuverCount == intervalPointsArray[4])
          {
            calculatedSteeringValue = maxSteeringAngle;
            NMinusTwoSteeringVal = maxSteeringAngle;
          }
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(maxSteeringAngle);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(maxSteeringAngle);
          write("Step 3: hold on + max %d to %d Val = + %f",intervalPointsArray[4],intervalPointsArray[5],maxSteeringAngle);
        }
        else if((steeringManeuverCount <= intervalPointsArray[7]) && (steeringManeuverCount >= intervalPointsArray[6]))
        {
          executeNegSteering();
        }
        else if((steeringManeuverCount <= intervalPointsArray[9]) && (steeringManeuverCount >= intervalPointsArray[8]))
        {
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(-maxSteeringAngle);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec =  degreesToRadians(-maxSteeringAngle);
          write("Step 3: Hold on - max %d to %d Val = - %f",intervalPointsArray[8],intervalPointsArray[9],maxSteeringAngle);
        }
        else if(steeringManeuverCount >= intervalPointsArray[9])
        {
          // 4- Set mission to executed
          $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 7; // Mission arrived
          //accelerateToSpeed(0);
        }
      }
      else if(steeringManeuverCount >= (intervalPointsArray[9] + 1))
      {
        SteeringCounter++;
      }
      setTimer(sequenceTimerSmooth, sequenceRateFast); // 100ms delay before next step
      break;
    case 4:
      teststep("Steering Test","Step 4: Reset Mission and Steering Request angle.");
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 7; // Mission arrived
      $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
      $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 3; // Mission accepted
      validationTimer++;
      if(validationTimer > 50)
      {
        SteeringCounter++;
        validationTimer = 0;
      }
      testWaitForTimeout(TEST_STEERING_TIMOUT);
      accelerateToSpeed(STOP_ACC);
      setTimer(sequenceTimerSmooth, sequenceRateFast); // 100ms delay before next step
    default:
      // End of sequence
      calculatedSteeringValue = 0;
      NMinusTwoSteeringVal = 0;
      NMinusOneSteeringVal = 0;
      steeringManeuverCount = 0;
      cancelTimer(sequenceTimerSmooth);
      teststep("Steering Test","Sequence Completed", "All steps executed successfully.");
      maneuverInProgress = 0;
      break;
  }
}

// Timer event for sequential execution
on timer sequenceTimerLimiter
{
  
  switch (SteeringCounter)
  {
    case 0: //0 - Set maneuver state and reset acc counter 
      maneuverInProgress = 1;
      TC005_testVSMStatus(AUTO_VAL);
      teststep("Steering Test","Step 0: Set mission and reset acc counter");
      setSDSSimParams(MANEUVER_STATE);
      SteeringCounter++;
      setTimer(sequenceTimerLimiter, sequenceRate); // 100ms delay before next step
      break;

    case 1: // 1- Set Drive/Auto
      testStep("Steering Test","Step 1: Set Drive/Auto");
      $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::GearchangeReqPri = DRIVE_GEAR;
      TC001_testGearchangeReqPrimary(DRIVE_GEAR);
      if(DISABLE_VCU_SIGNALS == 0)
      {
        $CHASSIS1CAN::VCU_VSMInfo::VSMStatus = AUTO_VAL;
        $CHASSIS2CAN::VCU_VSMInfo::VSMStatus = AUTO_VAL;
      }
      
      /*---------------------------------------RUN TESTCASES: START--------------------------------------------*/
      TC002_verifySDSPrimarySignals();
      TC003_verifySDSSecondarySignals();
      TC004_verifyPWT1Signals();
      
      /*---------------------------------------RUN TESTCASES: END----------------------------------------------*/
      
      SteeringCounter++;
      setTimer(sequenceTimerLimiter, sequenceRate); // 100ms delay before next step
      break;

    case 2:
      if(accCount == 0)
      {
        testStep("Steering Test","Step 2: Accelerate to target Speed");
      }
      
      // 2- Accelerate to targetSpeed
      accCount++;
      if(accCount == 22) // after 2 seconds since maneuver is executed reset to 0
      {
        $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::VehStandStillReqPri = 0;
        TC006_testVehStandStillReqPrimary(2);
      }
      accelerateToSpeed(START_ACC);
      
      if(accCount == 150) // Accelerate for 7 seconds max
      {
        SteeringCounter++;
        steeringManeuverCount = 0; // Reset counter
        accCount = 0; // Reset counter
        accelerateToSpeed(STOP_ACC); 
        setIntervals();
      }
      PowerTrainPreconditions();
      setTimer(sequenceTimerLimiter, sequenceRate); // 100ms delay before next step
      
      break;
      
    case 3:
      // 3 - Steer per test values (300 values in total) evrey 100ms
        steeringManeuverCount++;
        accelerateToSpeed(START_ACC);
        if((steeringManeuverCount <= 9) && (steeringManeuverCount >= 0))
        {
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
          write("Step 3: Hold on zero %d to %d Val = %f",intervalPointsArray[0],intervalPointsArray[1],0);
        }
        else
        {
          $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(507);
          $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(507);
          write("Step 3: Hold on 507 degrees.");
        }
        
        if(steeringManeuverCount == 40)
        {
          TG_003_Steering_50_testAngleLimiter();
          SteeringCounter++;
        }
        
        if(steeringManeuverCount == 20)
        {
          TG_003_Steering_50_testRateLimiter();
        }
        
        
      
      setTimer(sequenceTimerLimiter, sequenceRate); // 100ms delay before next step
      break;
    case 4:
      teststep("Steering Test","Step 4: Reset Mission and Steering Request angle.");
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 7; // Mission arrived
      $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(0);
      $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(0);
      $CHASSIS2CAN::SDS_Primary::SDS_Status_Prim::MissionProgressStat_Pri = 3; // Mission accepted
      validationTimer++;
      if(validationTimer > 50)
      {
        SteeringCounter++;
        validationTimer = 0;
      }
      testWaitForTimeout(TEST_STEERING_TIMOUT);
      accelerateToSpeed(STOP_ACC);
      setTimer(sequenceTimerLimiter, sequenceRate); // 100ms delay before next step
    default:
      // End of sequence
      calculatedSteeringValue = 0;
      NMinusTwoSteeringVal = 0;
      NMinusOneSteeringVal = 0;
      steeringManeuverCount = 0;
      cancelTimer(sequenceTimerLimiter);
      teststep("Steering Test","Sequence Completed", "All steps executed successfully.");
      maneuverInProgress = 0;
      break;
  }
}


testcase TC007_validateISCS1SteeringResults()
{
  int i;
  double expectedVal;
  double tolerance = 15; 

  for (i = 0; i < MAX_STEERING_TEST_BUFFER_SIZE; i++)
  {
    expectedVal = calculatedPinionAngleBuffer[i];
    validateISCSSteeringSample(i, -expectedVal, iscsPinionAngle1Buffer[i], tolerance);
  }
}


testcase TC008_validateISCS2SteeringResults()
{
  int i;
  double expectedVal;
  double tolerance = 15; 

  for (i = 0; i < MAX_STEERING_TEST_BUFFER_SIZE; i++)
  {
    expectedVal = calculatedPinionAngleBuffer[i];
    validateISCSSteeringSample(i, -expectedVal, iscsPinionAngle2Buffer[i], tolerance);  
  }
}
  

testfunction validateISCSSteeringSample(int sampleIndex, double expectedVal, double actualVal, double tolerance)
{
  if (abs(actualVal - degreesToRadians(expectedVal)) > tolerance)
  {
    testStep("Steering Test", "Mismatch at sample %d: expected %.2f, got %.2f", sampleIndex, degreesToRadians(expectedVal), actualVal);
    write("validateISCS1SteeringResults: Mismatch at sample %d: expected %.2f, got %.2f", sampleIndex, degreesToRadians(expectedVal), actualVal);
    TestStepFail("ISCS", "Mismatch at sample %d in ISCS", sampleIndex);
  }
  else
  {
    testStepPass("ISCS", "Sample %d passed: expected %.2f, got %.2f", sampleIndex, expectedVal, actualVal);
  }
}


void executePosSteering()
{
    float steeringRate;
  
    switch(EXECUTED_MANEUVER)
    {
      case TG_003_Steering_0:
        steeringRate = STEERING_RATE_PROFILE_0;
        break;
      case TG_003_Steering_0_Smooth:
        steeringRate = STEERING_RATE_PROFILE_0_SMOOTH;
        break;
      case TG_003_Steering_10:
        steeringRate = STEERING_RATE_PROFILE_10;
        break;
        
      case TG_003_Steering_20:
        steeringRate = STEERING_RATE_PROFILE_20;
        break;
        
      case TG_003_Steering_30:
        steeringRate = STEERING_RATE_PROFILE_30;
        break;
        
      case TG_003_Steering_40:
        steeringRate = STEERING_RATE_PROFILE_40;
        break;
        
      case TG_003_Steering_50:
        steeringRate = STEERING_RATE_PROFILE_50;
        break;
        
      case TG_003_Steering_50_limiter:
        steeringRate = STEERING_RATE_PROFILE_50;
        break;
        
      case TG_003_Steering_60:
      case TG_004_Steering_Braking_60:
        steeringRate = STEERING_RATE_PROFILE_60;
        break;
      default:
        steeringRate = STEERING_RATE_PROFILE_60;
        break;
    }
    
    Pos_Dir_Steering(steeringRate);
}


void executeNegSteering()
{
    float steeringRate;
  
    switch(EXECUTED_MANEUVER)
    {
      case TG_003_Steering_0:
        steeringRate = STEERING_RATE_PROFILE_0;
        break;
      case TG_003_Steering_0_Smooth:
        steeringRate = STEERING_RATE_PROFILE_0_SMOOTH;
        break;
      case TG_003_Steering_10:
        steeringRate = STEERING_RATE_PROFILE_10;
        break;
        
      case TG_003_Steering_20:
        steeringRate = STEERING_RATE_PROFILE_20;
        break;
        
      case TG_003_Steering_30:
        steeringRate = STEERING_RATE_PROFILE_30;
        break;
        
      case TG_003_Steering_40:
        steeringRate = STEERING_RATE_PROFILE_40;
        break;
        
      case TG_003_Steering_50:
        steeringRate = STEERING_RATE_PROFILE_50;
        break;
        
      case TG_003_Steering_60:
      case TG_004_Steering_Braking_60:
        steeringRate = STEERING_RATE_PROFILE_60;
        break;
      default:
        steeringRate = STEERING_RATE_PROFILE_60;
        break;
    }
    
    Neg_Dir_Steering(steeringRate);
}

void Pos_Dir_Steering(float SteeringRateFactor)
{
  calculatedSteeringValue = NMinusOneSteeringVal + SteeringRateFactor;
  $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(calculatedSteeringValue);
  $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(calculatedSteeringValue);  
  NMinusOneSteeringVal = calculatedSteeringValue;
  write("SteeringManeuver = %d  calculatedSteeringValue = %f",steeringManeuverCount,calculatedSteeringValue);
}



void Neg_Dir_Steering(float SteeringRateFactor)
{
  calculatedSteeringValue = NMinusTwoSteeringVal - SteeringRateFactor;  
  $CHASSIS2CAN::SDS_CtrlSteeringWheel_Prim::CtrlSteeringPinionAngle_Pri = degreesToRadians(calculatedSteeringValue);
  $CHASSIS1CAN::SDS_CtrlSteeringWheel_Sec::CtrlSteeringPinionAngle_Sec = degreesToRadians(calculatedSteeringValue);
  NMinusTwoSteeringVal = calculatedSteeringValue;
  write("SteeringManeuver = %d  calculatedSteeringValue = %f",steeringManeuverCount,calculatedSteeringValue);
}



void accelerateToSpeed(int accIO)
{
    float targetSpeed;
    float tolerance; 
    
  if(accIO == START_ACC)
  {
    switch(EXECUTED_MANEUVER)
    {
      case TG_003_Steering_0:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_0;
          tolerance = TOLERANCE_ACC_PROFILE_0;
        break;
      case TG_003_Steering_10:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_10;
          tolerance = TOLERANCE_ACC_PROFILE_10;
        break;
        
      case TG_003_Steering_20:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_20;
          tolerance = TOLERANCE_ACC_PROFILE_20;
        break;
        
      case TG_003_Steering_30:
          ACC_VAL = TARGET_ACC_1; 
          targetSpeed = TARGET_SPEED_PROFILE_30;
          tolerance = TOLERANCE_ACC_PROFILE_30;
        break;
        
      case TG_003_Steering_40:
          ACC_VAL = TARGET_ACC_2;
          targetSpeed = TARGET_SPEED_PROFILE_40;
          tolerance = TOLERANCE_ACC_PROFILE_40;
        break;
        
      case TG_003_Steering_50:
      case TG_003_Steering_50_limiter:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_50;
          tolerance = TOLERANCE_ACC_PROFILE_50;
        break;
        
      case TG_003_Steering_60:
      case TG_004_Steering_Braking_60:
          ACC_VAL = TARGET_ACC_2;
          targetSpeed = TARGET_SPEED_PROFILE_60;
          tolerance = TOLERANCE_ACC_PROFILE_60;
        break;
        

        
      case TG_001_Acceleration_2_D1:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_ACC1;
          tolerance = TOLERANCE_ACC_PROFILE_ACC1;
        break;
        
      case TG_001_Acceleration_2_D2:
          ACC_VAL = TARGET_ACC_2;
          targetSpeed = TARGET_SPEED_PROFILE_ACC2;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      case TG_001_Acceleration_2_D1R:
          ACC_VAL = TARGET_ACC_1;
          targetSpeed = TARGET_SPEED_PROFILE_ACC1;
          tolerance = TOLERANCE_ACC_PROFILE_ACC1;
        break;
        
      case TG_001_Acceleration_2_D2R:
          ACC_VAL = TARGET_ACC_2;
          targetSpeed = TARGET_SPEED_PROFILE_ACC2;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      case TG_002_BRAKING_30_3_5:
          ACC_VAL = TARGET_ACC_BRAKING;
          targetSpeed = TARGET_SPEED_PROFILE_BRAK_30;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      case TG_002_BRAKING_30_5:
          ACC_VAL = TARGET_ACC_BRAKING;
          targetSpeed = TARGET_SPEED_PROFILE_BRAK_30;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      case TG_002_BRAKING_50_3_5:
          ACC_VAL = TARGET_ACC_BRAKING;
          targetSpeed = TARGET_SPEED_PROFILE_BRAK_50;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      case TG_002_BRAKING_50_5:
          ACC_VAL = TARGET_ACC_BRAKING;
          targetSpeed = TARGET_SPEED_PROFILE_BRAK_50;
          tolerance = TOLERANCE_ACC_PROFILE_ACC2;
        break;
        
      default:
        
        break;
    }
  }
  else if(accIO == STOP_ACC)
  {
    targetSpeed = TARGET_SPEED_PROFILE_0;
    tolerance = TARGET_SPEED_PROFILE_0;
  }
    

    write("Setting acceleration to %f m/s with a tolerance of %f m/s ... ",targetSpeed, tolerance);
    currentSpeed = getSignal(CHASSIS1CAN::MKC1_VehMvmntInfo::VehSpeedCalcStat);
    
        // Check if the speed is within the tolerance range
        if (currentSpeed >= targetSpeed - tolerance && currentSpeed <= targetSpeed + tolerance)
        {
            // If within tolerance range, stop acceleration
            $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = 0;
            $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = 0;
            Chass2SDSStabInfSec.AccelDecelReqSec = 0;
            Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
            Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
            Chass2SDSStabInfSec.VehStandStillReqSec = 0;
            Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
            setTimer(PWT100Timer,PWT100TimerVal);
           
        }
        else if (currentSpeed < targetSpeed - tolerance)
        {
            // If current speed is less than target speed minus tolerance, continue accelerating
            $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = 1.3;
            $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = 1.3;
            Chass2SDSStabInfSec.AccelDecelReqSec = 1.3;
            Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
            Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
            Chass2SDSStabInfSec.VehStandStillReqSec = 0;
            Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
            setTimer(PWT100Timer,PWT100TimerVal);
        }
        else if (currentSpeed > targetSpeed + tolerance)
        {
            // If current speed is greater than target speed plus tolerance, stop acceleration
            $CHASSIS2CAN::SDS_Primary::SDS_Stability_Info_Prim::AccelDecelReqPri = 0;
            $CHASSIS1CAN::SDS_Secondary::SDS_Stability_Info_Sec::AccelDecelReqSec = 0;
            Chass2SDSStabInfSec.AccelDecelReqSec = 0;
            Chass2SDSStabInfSec.AccelDecelReqSecValidStat = 1;
            Chass2SDSStabInfSec.GearchangeReq_Sec = 1;
            Chass2SDSStabInfSec.VehStandStillReqSec = 0;
            Chass2SDSStabInfSec.VehStandStillReqValiditySec = 1;
            setTimer(PWT100Timer,PWT100TimerVal);
        }
}


void setSteeringValidity(int validity)
{
      if(validity == VALID_STATE)
      {
        $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::Valid_CtrlSteeringPinionAng_Pri = validity;
        $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::Valid_CtrlSteeringPinionAng_Sec = validity;
        teststep(" ","Validity of Steering is set to VALID_STATE (%d). ", validity);
      }
      else if(validity == INVALID_STATE)
      {
        $CHASSIS2CAN::SDS_Primary::SDS_CtrlSteeringWheel_Prim::Valid_CtrlSteeringPinionAng_Pri = validity;
        $CHASSIS1CAN::SDS_Secondary::SDS_CtrlSteeringWheel_Sec::Valid_CtrlSteeringPinionAng_Sec = validity;
        teststep(" ","Validity of Steering is set to INVALID_STATE (%d).", validity);
      }
      else
      {
        teststep(" ","Incompatible value set to Steering Validity State. ");
      }
}


// Function to convert degrees to radians
float degreesToRadians(float degrees) 
{
  return degrees * 3.14159265359 / 180.0;
}

// Function to convert raw sensor value to pinion angle
float convertRawToAngle(int rawValue) 
{
  return (-0.5081 * rawValue) + 754.5;
}

// Function to convert pinion angle to raw sensor value
int convertAngleToRaw(float angle) 
{
  return (int)((angle - 754.5) / -0.5081);
}






void resetVariables()
{
  calculatedSteeringValue = 0;
  currentSpeed = 0;
  NMinusOneSteeringVal = 0;
  NMinusTwoSteeringVal = 0;
  
  preconditionsStep = 0;
  steeringManeuverCount = 0;
  SteeringCounter = 0;
  accCount = 0;

}

void cancelAllTimers()
{
  cancelTimer(sequenceTimer);
  cancelTimer(sequenceTimerLimiter);
  cancelTimer(PWT100Timer);
  cancelTimer(PWT50Timer);
  cancelTimer(preconditionsTimer);
  stop(); // Stops measurement
}
